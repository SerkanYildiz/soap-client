{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"General purpose PHP SOAP-client Sick and tired of building crappy SOAP implementations? This package aims to help you with some common SOAP integration pains in PHP. Its goal is to make integrating with SOAP fun again! Let's inspect some of the pains that are solved by this package: Demo Installation $ composer require phpro/soap-client Scafolding Wizard Since life is too short to read documentation, we've added a scafolding wizard which will get you communicating with your SOAP server in no time! All you need to do is: composer require --dev zendframework/zend-code:^3.1.0 ./vendor/bin/soap-client wizard You can customize the generated code based on the manual installation pages in the next chapter. Getting your SOAP integration up and running Create your own SOAP client. Generate PHP classes based on SOAP types. Generate a class map Generate your own SOAP client. Generate a client factory. Use your SOAP client. Test your SOAP client. Advanced configuration Add type converters. Listen to events. Logger plugin Validator plugin Caching plugin Specify your data transfer handler. SoapHandle HTTPlugHandle LocalSoapServerHandle Configure one or multiple HTTP middlewares. BasicAuthMiddleware NtlmMiddleware WsaMiddleware WsseMiddleware Select a WSDL Provider Customize the code generation Configuration Specify generation Rules Generate code through Assemblers Why this soap client was made By default, the SoapClient works with a mix of arrays, stdClasses and other scalar types. This is not a good practice in a modern OOP world because: It makes your code hard to test. It breaks Code Completion It is hard to track changes in the response and request objects. The content of a result is never explicit. To solve the above problems, this package will force you into using Value-objects for Requests and Responses. We know that maintaining these value-objects can be a load of work. No worries! There are some commandline tools available that will help you with generating a good base to start with. Because the SoapClient will need a classmap of WSDL to PHP Classes, there is also a classmap generator available. This will surely safe you a lot of time! By adding SOAP type converters, it is possible to transform the values of a specific SOAP type from/to a PHP type. The package comes included with some basic transformers for date and datetime. On, top of that, it is very easy to create your own transformers. Another problem is that the native SoapClient works with a lot of magic methods. It is hard to debug these magic methods hence there is no code completion. Both SOAP and implementation methods are on the same object. This package will force you into wrapping a SoapClient into your own Client. You can choose to only expose the methods you need. It will always be clear to the developer what's in your client, how it works and what it returns. We even provided a base Client for you to use with some common used methods for debugging, authentication and an event system. In lots of SOAP integrations, the logging, caching and Soap calls are in the same method. This makes your code hard to read and dependent on other classes / packages. Creating a great OO SOAP client means that you'll have to create a lot of code. This can be a tedious task which can be automated. That is why we've added the tools to automatically generate the SOAP objects from the XSD scheme inside the WSDL. It is even possible to specify your own code-generation rules and code assemblers or use one of our many built-in classes. It is important keep your code clean. Therefore, we added an event-listener to your Soap client. You can hook in at every important step of the SOAP flow. This way it is possible to add logging, validation, caching and error handling with event subscribers. Pretty cool right?! Implementing SOAP extensions is a real pain in the ass. It forces you to overwrite core methods of the built-in SOAP client. If you ever had to implement WSA or WSSE in SOAP, you know that there is something wrong in the core. Therefore, we made it easy for you to extend our SOAP client. You can specify which data transfer handler like e.g. Guzzle you want to use. Depending on the selected handler, you can easily add support for SOAP extensions or advanced authentication through HTTP middlewares. Testing webservices is hard! That is why this package is fully compatible with php-vcr . Testing your SOAP client will be very fast and without any errors at the 3th party side of the integration. Last but not least, we want to make it easy for you to configure your SoapClient. That is why we included a ClientBuilder on which you can configure your custom Client. You want some other settings during development and in production? No problem! Sit back and let the ClientBuilder handle your Client initialisation.","title":"Home"},{"location":"#general-purpose-php-soap-client","text":"Sick and tired of building crappy SOAP implementations? This package aims to help you with some common SOAP integration pains in PHP. Its goal is to make integrating with SOAP fun again! Let's inspect some of the pains that are solved by this package:","title":"General purpose PHP SOAP-client"},{"location":"#demo","text":"","title":"Demo"},{"location":"#installation","text":"$ composer require phpro/soap-client","title":"Installation"},{"location":"#scafolding-wizard","text":"Since life is too short to read documentation, we've added a scafolding wizard which will get you communicating with your SOAP server in no time! All you need to do is: composer require --dev zendframework/zend-code:^3.1.0 ./vendor/bin/soap-client wizard You can customize the generated code based on the manual installation pages in the next chapter.","title":"Scafolding Wizard"},{"location":"#getting-your-soap-integration-up-and-running","text":"Create your own SOAP client. Generate PHP classes based on SOAP types. Generate a class map Generate your own SOAP client. Generate a client factory. Use your SOAP client. Test your SOAP client.","title":"Getting your SOAP integration up and running"},{"location":"#advanced-configuration","text":"Add type converters. Listen to events. Logger plugin Validator plugin Caching plugin Specify your data transfer handler. SoapHandle HTTPlugHandle LocalSoapServerHandle Configure one or multiple HTTP middlewares. BasicAuthMiddleware NtlmMiddleware WsaMiddleware WsseMiddleware Select a WSDL Provider","title":"Advanced configuration"},{"location":"#customize-the-code-generation","text":"Configuration Specify generation Rules Generate code through Assemblers","title":"Customize the code generation"},{"location":"#why-this-soap-client-was-made","text":"By default, the SoapClient works with a mix of arrays, stdClasses and other scalar types. This is not a good practice in a modern OOP world because: It makes your code hard to test. It breaks Code Completion It is hard to track changes in the response and request objects. The content of a result is never explicit. To solve the above problems, this package will force you into using Value-objects for Requests and Responses. We know that maintaining these value-objects can be a load of work. No worries! There are some commandline tools available that will help you with generating a good base to start with. Because the SoapClient will need a classmap of WSDL to PHP Classes, there is also a classmap generator available. This will surely safe you a lot of time! By adding SOAP type converters, it is possible to transform the values of a specific SOAP type from/to a PHP type. The package comes included with some basic transformers for date and datetime. On, top of that, it is very easy to create your own transformers. Another problem is that the native SoapClient works with a lot of magic methods. It is hard to debug these magic methods hence there is no code completion. Both SOAP and implementation methods are on the same object. This package will force you into wrapping a SoapClient into your own Client. You can choose to only expose the methods you need. It will always be clear to the developer what's in your client, how it works and what it returns. We even provided a base Client for you to use with some common used methods for debugging, authentication and an event system. In lots of SOAP integrations, the logging, caching and Soap calls are in the same method. This makes your code hard to read and dependent on other classes / packages. Creating a great OO SOAP client means that you'll have to create a lot of code. This can be a tedious task which can be automated. That is why we've added the tools to automatically generate the SOAP objects from the XSD scheme inside the WSDL. It is even possible to specify your own code-generation rules and code assemblers or use one of our many built-in classes. It is important keep your code clean. Therefore, we added an event-listener to your Soap client. You can hook in at every important step of the SOAP flow. This way it is possible to add logging, validation, caching and error handling with event subscribers. Pretty cool right?! Implementing SOAP extensions is a real pain in the ass. It forces you to overwrite core methods of the built-in SOAP client. If you ever had to implement WSA or WSSE in SOAP, you know that there is something wrong in the core. Therefore, we made it easy for you to extend our SOAP client. You can specify which data transfer handler like e.g. Guzzle you want to use. Depending on the selected handler, you can easily add support for SOAP extensions or advanced authentication through HTTP middlewares. Testing webservices is hard! That is why this package is fully compatible with php-vcr . Testing your SOAP client will be very fast and without any errors at the 3th party side of the integration. Last but not least, we want to make it easy for you to configure your SoapClient. That is why we included a ClientBuilder on which you can configure your custom Client. You want some other settings during development and in production? No problem! Sit back and let the ClientBuilder handle your Client initialisation.","title":"Why this soap client was made"},{"location":"client/","text":"Creating your custom client The first thing you need to do is creating your own client. We provided a base Client class which already has some basic features. An example of your custom Client looks like this: class YourClient extends Client { /** * @param RequestInterface $request * * @return ResultInterface * @throws \\Phpro\\SoapClient\\Exception\\SoapException */ public function helloWorld(RequestInterface $request) { return $this- call('HelloWorld', $request); } } As you can see, this custom client extends the Client class. It is also possible to implement the ClientInterface . This means you will also have to create a ClientFactory which can instantiate your custom Client. The SoapClient is injected inside your YourClient class and will not be accessible to the outside world. The methods of the class are explicitly defined and have explicit parameters and return types. Request value-objects that are passed to the call method, MUST implement the RequestInterface . SOAP responses can have 2 types: ResultProviderInterface or ResultInterface . The ResultProviderInterface can be used if the response type is wrapping a ResultInterface . The call method will initailize the SOAP call and trigger the subscribed event listeners. As you can see, we've normalized the exception. Our SOAP client will always throw a custom SoapException . This is to make it possible to use multiple different handlers which don't always throw a SoapFault . My SOAP service does not work with Request / Response objects. In older SOAP services, it is possible that it is impossible to request with a RequestInterface . Those services typically require multiple SOAP arguments in the method. This is why we created a MultiArgumentRequestInterface . With this interface, you can still use our SOAP client, but send multiple arguments to the SOAP service. $request = new MultiArgumentRequest(['argument1', 'argument2']) $response = $client- someMethodWithMultipleArguments($request) When the SOAP service is returning an internal PHP type, the result is being wrapped with a MixedResult class. This way, you don't have to worry about the internal type of the SOAP response. /** @var MixedResult $result */ $result = $client- someMethodWithInternalTypeResult($request); $actualResponse = $response- getResponse();","title":"Creating your custom client"},{"location":"client/#creating-your-custom-client","text":"The first thing you need to do is creating your own client. We provided a base Client class which already has some basic features. An example of your custom Client looks like this: class YourClient extends Client { /** * @param RequestInterface $request * * @return ResultInterface * @throws \\Phpro\\SoapClient\\Exception\\SoapException */ public function helloWorld(RequestInterface $request) { return $this- call('HelloWorld', $request); } } As you can see, this custom client extends the Client class. It is also possible to implement the ClientInterface . This means you will also have to create a ClientFactory which can instantiate your custom Client. The SoapClient is injected inside your YourClient class and will not be accessible to the outside world. The methods of the class are explicitly defined and have explicit parameters and return types. Request value-objects that are passed to the call method, MUST implement the RequestInterface . SOAP responses can have 2 types: ResultProviderInterface or ResultInterface . The ResultProviderInterface can be used if the response type is wrapping a ResultInterface . The call method will initailize the SOAP call and trigger the subscribed event listeners. As you can see, we've normalized the exception. Our SOAP client will always throw a custom SoapException . This is to make it possible to use multiple different handlers which don't always throw a SoapFault .","title":"Creating your custom client"},{"location":"client/#my-soap-service-does-not-work-with-request-response-objects","text":"In older SOAP services, it is possible that it is impossible to request with a RequestInterface . Those services typically require multiple SOAP arguments in the method. This is why we created a MultiArgumentRequestInterface . With this interface, you can still use our SOAP client, but send multiple arguments to the SOAP service. $request = new MultiArgumentRequest(['argument1', 'argument2']) $response = $client- someMethodWithMultipleArguments($request) When the SOAP service is returning an internal PHP type, the result is being wrapped with a MixedResult class. This way, you don't have to worry about the internal type of the SOAP response. /** @var MixedResult $result */ $result = $client- someMethodWithInternalTypeResult($request); $actualResponse = $response- getResponse();","title":"My SOAP service does not work with Request / Response objects."},{"location":"events/","text":"Hooking in with events The Client class has a build-in EventDispatcher. It will trigger events at all important phases of the SOAP call: Events::REQUEST (RequestEvent) Events::RESPONSE (ResponseEvent) Events::FAULT (FaultEvent) You can subscribe your own listeners to the configured EventDispatcher . For example: class ResponseFailedSubscriber implements SubscriberInterface { // implement interface } $dispatcher- addSubscriber(new ResponseFailedSubscriber()); This package ships with some default subscriber plugins: Logger plugin Validator plugin Caching plugin","title":"Hooking in with events"},{"location":"events/#hooking-in-with-events","text":"The Client class has a build-in EventDispatcher. It will trigger events at all important phases of the SOAP call: Events::REQUEST (RequestEvent) Events::RESPONSE (ResponseEvent) Events::FAULT (FaultEvent) You can subscribe your own listeners to the configured EventDispatcher . For example: class ResponseFailedSubscriber implements SubscriberInterface { // implement interface } $dispatcher- addSubscriber(new ResponseFailedSubscriber()); This package ships with some default subscriber plugins: Logger plugin Validator plugin Caching plugin","title":"Hooking in with events"},{"location":"handlers/","text":"Use your preferred data transfer layer with Handlers The build-in SOAP client doesn't support extensions by default. To overcome this problem, you are forced to overwrite the __doRequest() method. By doing this, your code will be tied to the SoapClient which makes it hard to test and to reuse the logic. This package contains a handler system which allows you to get control over the HTTP layer of the soap client. The handler system makes it possible to make changes to the request and the response before sending it to the server. Here is a list of built-in handlers: SoapHandle HttPlugHandle LocalSoapServerHandle SoapHandle Features: LastRequestInfoCollector The SoapHandle is used by default and works with the built-in __doRequest() method. This Handle is not configurable and can be used for soap implementations which do not use extensions. It is activated by default to get you going as quick as posible. Configuration $clientBuilder = new ClientBuilder($clientFactory, $wsdl, $soapOptions); $client = $clientBuilder- build(); HttPlugHandle Features: LastRequestInfoCollector, MiddlewareSupporting HTTPlug is a HTTP client abstraction that can be used with multiple client packages. With this handler it is easy to get in control about the HTTP layer of the SOAP client. You can specify one or multiple middlewares that are being applied on your http client. This makes it possible to manipulate the request and response objects so that you can get full control. This handler is based on middlewares which are applied to your guzzle client. You can read more about middlewares in this section. Dependencies Load HTTP plug core packages: composer require psr/http-message:^1.0 php-http/httplug:^1.1 php-http/message-factory:^1.0 php-http/discovery:^1.3 php-http/message:^1.6 php-http/client-common:^1.6 Select HTTP Client Select one of the many clients you want to use to perform the HTTP requests: http://docs.php-http.org/en/latest/clients.html#clients-adapters composer require php-http/client-implementation:^1.0 Configuration $clientBuilder = new ClientBuilder($clientFactory, $wsdl, $soapOptions); $clientBuilder- withHandler(HttPlugHandle::createForClient($httpClient)); $client = $clientBuilder- build(); LocalSoapServerHandle Features: LastRequestInfoCollector The LocalSoapServerHandle can be used to link the soap-client to a local PHP SoapServer instance. This handle can be used for testing purposes, it is not recommended to use it in production. *NOTE: * Since SoapServer is sending headers, you want to run this handler in a separate process. You can use @runInSeparateProcess in PHPunit. Configuration $soapServer = new \\SoapServer('some.wsdl', []); $soapServer- setObject($someTestingImplementation); $clientBuilder = new ClientBuilder($clientFactory, $wsdl, $soapOptions); $clientBuilder- withHandler(new LocalSoapServerHandle($soapServer)); $client = $clientBuilder- build();","title":"Use your preferred data transfer layer with Handlers"},{"location":"handlers/#use-your-preferred-data-transfer-layer-with-handlers","text":"The build-in SOAP client doesn't support extensions by default. To overcome this problem, you are forced to overwrite the __doRequest() method. By doing this, your code will be tied to the SoapClient which makes it hard to test and to reuse the logic. This package contains a handler system which allows you to get control over the HTTP layer of the soap client. The handler system makes it possible to make changes to the request and the response before sending it to the server. Here is a list of built-in handlers: SoapHandle HttPlugHandle LocalSoapServerHandle","title":"Use your preferred data transfer layer with Handlers"},{"location":"handlers/#soaphandle","text":"Features: LastRequestInfoCollector The SoapHandle is used by default and works with the built-in __doRequest() method. This Handle is not configurable and can be used for soap implementations which do not use extensions. It is activated by default to get you going as quick as posible. Configuration $clientBuilder = new ClientBuilder($clientFactory, $wsdl, $soapOptions); $client = $clientBuilder- build();","title":"SoapHandle"},{"location":"handlers/#httplughandle","text":"Features: LastRequestInfoCollector, MiddlewareSupporting HTTPlug is a HTTP client abstraction that can be used with multiple client packages. With this handler it is easy to get in control about the HTTP layer of the SOAP client. You can specify one or multiple middlewares that are being applied on your http client. This makes it possible to manipulate the request and response objects so that you can get full control. This handler is based on middlewares which are applied to your guzzle client. You can read more about middlewares in this section. Dependencies Load HTTP plug core packages: composer require psr/http-message:^1.0 php-http/httplug:^1.1 php-http/message-factory:^1.0 php-http/discovery:^1.3 php-http/message:^1.6 php-http/client-common:^1.6 Select HTTP Client Select one of the many clients you want to use to perform the HTTP requests: http://docs.php-http.org/en/latest/clients.html#clients-adapters composer require php-http/client-implementation:^1.0 Configuration $clientBuilder = new ClientBuilder($clientFactory, $wsdl, $soapOptions); $clientBuilder- withHandler(HttPlugHandle::createForClient($httpClient)); $client = $clientBuilder- build();","title":"HttPlugHandle"},{"location":"handlers/#localsoapserverhandle","text":"Features: LastRequestInfoCollector The LocalSoapServerHandle can be used to link the soap-client to a local PHP SoapServer instance. This handle can be used for testing purposes, it is not recommended to use it in production. *NOTE: * Since SoapServer is sending headers, you want to run this handler in a separate process. You can use @runInSeparateProcess in PHPunit. Configuration $soapServer = new \\SoapServer('some.wsdl', []); $soapServer- setObject($someTestingImplementation); $clientBuilder = new ClientBuilder($clientFactory, $wsdl, $soapOptions); $clientBuilder- withHandler(new LocalSoapServerHandle($soapServer)); $client = $clientBuilder- build();","title":"LocalSoapServerHandle"},{"location":"middlewares/","text":"Get control of the HTTP layer with middlewares If the SOAP server has some extensions enabled, it is hard to get them working with the built-in SOAP client. In many cases, you'll have to transform the XML request before sending it to the server or normalize the response XML before converting it back to objects. It is also possible to specify some custom HTTP headers to make sure you can authenticate on the remote server. To make sure your soap-client can work with middlewares, you'll have to check if your data transfer handler supports middlewares. You can take a look to the list of handlers and check if your handler has the feature \"MiddlewareSupporting\". Next, you can use one of the built-in middlewares: BasicAuthMiddleware NtlmMiddleware (deprecated) WsaMiddleware WsseMiddleware RemoveEmptyNodesMiddleware Wsdl/DisableExtensionsMiddleware Can't find the middleware you were looking for? It is always possible to create your own one! Built-in middlewares BasicAuthMiddleware In many cases, your server had some kind of authentication enabled. This basic authentication middleware provides the features you need to add a username and password to the request. Usage $clientBuilder- addMiddleware(new BasicAuthMiddleware('username', 'password')); NtlmMiddleware Deprecated: since we moved from Guzzle, you will need to write your own NTLM auth implementation. Your best try is using a cURL Client with the following options: [CURLOPT_HTTPAUTH = CURLAUTH_NTLM, CURLOPT_USERPWD = 'user:pass'] . However, take care as there's a cURL misbehavior that might block you going forward with some SOAP servers. WsaMiddleware If your remote server expects Web Service Addressing (WSA) headers to be available in your request, you can easily activate this middleware. Internally it used the wse-php package of robrichards which is a well known library that is used by many developers. The middleware is a light wrapper that makes it easy to use in your application. Dependencies composer require robrichards/wse-php:^2.0 Usage $clientBuilder- addMiddleware(new WsaMiddleware()); WsseMiddleware If you ever had to implement Web Service Security (WSS / WSSE) manually, you know that it is a lot of work to get this one working. Luckily for you we created an easy to use WSSE middleware that can be used to sign your SOAP requests. Internally it used the wse-php package of robrichards which is a well known library that is used by many developers. The middleware is a light wrapper that makes it easy to use in your application. Dependencies composer require robrichards/wse-php:^2.0 Usage // Simple: $wsse = new WsseMiddleware('privatekey.pem', 'publickey.pyb'); // With signed headers. E.g: in combination with WSA: $wsse = new WsseMiddleware('privatekey.pem', 'publickey.pyb'); $wsse- withAllHeadersSigned(); // With configurable timestamp expiration: $wsse = new WsseMiddleware('privatekey.pem', 'publickey.pyb'); $wsse- withTimestamp(3600); // With plain user token: $wsse = new WsseMiddleware('privatekey.pem', 'publickey.pyb'); $wsse- withUserToken('username', 'password', false); // With digest user token: $wsse = new WsseMiddleware('privatekey.pem', 'publickey.pyb'); $wsse- withUserToken('username', 'password', true); // With end-to-end encryption enabled: $wsse = new WsseMiddleware('privatekey.pem', 'publickey.pyb'); $wsse- withEncryption('client-x509.pem'); $wsse- withServerCertificateHasSubjectKeyIdentifier(true); // Add it to the clientbuilder $clientBuilder- addMiddleware($wsse); RemoveEmptyNodesMiddleware Unset properties are converted into empty nodes in the request xml. If you need to remove all empty nodes from the request xml, you can simply add the remove empty nodes middleware. Usage $clientBuilder- addMiddleware(new RemoveEmptyNodesMiddleware()); Wsdl/DisableExtensionsMiddleware The default SOAP client does not support wsdl:required attributes since there is no SOAP extension mechanism in PHP. You will retrieve this exception: \"[SoapFault] SOAP-ERROR: Parsing WSDL: Unknown required WSDL extension\" when the WSDL does contain required SOAP extensions. This middleware can be used to set the \"wsdl:required\" property to false on the fly so that you don't have to change the WSDL on the server. Usage $wsdlProvier = HttPlugWsdlProvider::create($client); $wsdlProvider- addMiddleware(new DisableExtensionsMiddleware()); $clientBuilder- withWsdlProvider($wsdlProvider); Creating your own middleware Didn't find the middleware you needed? No worries! It is very easy to create your own middleware. We currently added a thin layer above HTTPlug plugins to make it easy to modify PSR-7 request and responses. The easiest way to get you starting is by extending the base Middleware class. You can specify your own beforeRequest() and afterResponse() method and manipulate whatever you like. class MyMiddleware extends \\Phpro\\SoapClient\\Middleware\\MiddleWare { public function getName(): string { return 'my_unique_middleware_name'; } /** * @param callable $handler * @param RequestInterface $request * @param array $options * * @return PromiseInterface */ public function beforeRequest(callable $handler, RequestInterface $request): Promise { return $handler($request, $options); } /** * @param ResponseInterface $response * * @return ResponseInterface */ public function afterResponse(ResponseInterface $response): ResponseInterface { return $response; } } XML manipulations Once you get a hang of creating your own middlewares, you'll find out that in many cases you need to manipulate the SOAP XML request or response. Because this XML is heavily namespaced, we created a SoapXml manipulator class. Example usage: // Load the XML from a PSR7 request or response: $xml = SoapXml::fromStream($request- getBody()); // Fetch specific elements: $dom = $xml- getXmlDocument(); $enveloppe = $xml- getEnvelope(); $headers = $xml- getHeaders(); $body = $xml- getBody(); $namespace = $xml- getSoapNamespaceUri(); // XML manipulations: $xml- addEnvelopeNamespace('alias', 'http://alias'); $newHeader = $xml- createSoapHeader(); $xml- prependSoapHeader($newHeader); // Xpath functions: $xml- registerNamespace('alias', 'http://alias'); $xml- xpath('/soap:Envelope')- item(0); // Use the manipulated XML in your PSR7 request or response: $request = $request- withBody($xml- toStream()) As you can see, this XML manipulation class is rather small at the moment but is super powerful. Internally it uses DOMDocument to make it possible to manipulate every little XML detail you want.","title":"Get control of the HTTP layer with middlewares"},{"location":"middlewares/#get-control-of-the-http-layer-with-middlewares","text":"If the SOAP server has some extensions enabled, it is hard to get them working with the built-in SOAP client. In many cases, you'll have to transform the XML request before sending it to the server or normalize the response XML before converting it back to objects. It is also possible to specify some custom HTTP headers to make sure you can authenticate on the remote server. To make sure your soap-client can work with middlewares, you'll have to check if your data transfer handler supports middlewares. You can take a look to the list of handlers and check if your handler has the feature \"MiddlewareSupporting\". Next, you can use one of the built-in middlewares: BasicAuthMiddleware NtlmMiddleware (deprecated) WsaMiddleware WsseMiddleware RemoveEmptyNodesMiddleware Wsdl/DisableExtensionsMiddleware Can't find the middleware you were looking for? It is always possible to create your own one!","title":"Get control of the HTTP layer with middlewares"},{"location":"middlewares/#built-in-middlewares","text":"","title":"Built-in middlewares"},{"location":"middlewares/#basicauthmiddleware","text":"In many cases, your server had some kind of authentication enabled. This basic authentication middleware provides the features you need to add a username and password to the request. Usage $clientBuilder- addMiddleware(new BasicAuthMiddleware('username', 'password'));","title":"BasicAuthMiddleware"},{"location":"middlewares/#ntlmmiddleware","text":"Deprecated: since we moved from Guzzle, you will need to write your own NTLM auth implementation. Your best try is using a cURL Client with the following options: [CURLOPT_HTTPAUTH = CURLAUTH_NTLM, CURLOPT_USERPWD = 'user:pass'] . However, take care as there's a cURL misbehavior that might block you going forward with some SOAP servers.","title":"NtlmMiddleware"},{"location":"middlewares/#wsamiddleware","text":"If your remote server expects Web Service Addressing (WSA) headers to be available in your request, you can easily activate this middleware. Internally it used the wse-php package of robrichards which is a well known library that is used by many developers. The middleware is a light wrapper that makes it easy to use in your application. Dependencies composer require robrichards/wse-php:^2.0 Usage $clientBuilder- addMiddleware(new WsaMiddleware());","title":"WsaMiddleware"},{"location":"middlewares/#wssemiddleware","text":"If you ever had to implement Web Service Security (WSS / WSSE) manually, you know that it is a lot of work to get this one working. Luckily for you we created an easy to use WSSE middleware that can be used to sign your SOAP requests. Internally it used the wse-php package of robrichards which is a well known library that is used by many developers. The middleware is a light wrapper that makes it easy to use in your application. Dependencies composer require robrichards/wse-php:^2.0 Usage // Simple: $wsse = new WsseMiddleware('privatekey.pem', 'publickey.pyb'); // With signed headers. E.g: in combination with WSA: $wsse = new WsseMiddleware('privatekey.pem', 'publickey.pyb'); $wsse- withAllHeadersSigned(); // With configurable timestamp expiration: $wsse = new WsseMiddleware('privatekey.pem', 'publickey.pyb'); $wsse- withTimestamp(3600); // With plain user token: $wsse = new WsseMiddleware('privatekey.pem', 'publickey.pyb'); $wsse- withUserToken('username', 'password', false); // With digest user token: $wsse = new WsseMiddleware('privatekey.pem', 'publickey.pyb'); $wsse- withUserToken('username', 'password', true); // With end-to-end encryption enabled: $wsse = new WsseMiddleware('privatekey.pem', 'publickey.pyb'); $wsse- withEncryption('client-x509.pem'); $wsse- withServerCertificateHasSubjectKeyIdentifier(true); // Add it to the clientbuilder $clientBuilder- addMiddleware($wsse);","title":"WsseMiddleware"},{"location":"middlewares/#removeemptynodesmiddleware","text":"Unset properties are converted into empty nodes in the request xml. If you need to remove all empty nodes from the request xml, you can simply add the remove empty nodes middleware. Usage $clientBuilder- addMiddleware(new RemoveEmptyNodesMiddleware());","title":"RemoveEmptyNodesMiddleware"},{"location":"middlewares/#wsdldisableextensionsmiddleware","text":"The default SOAP client does not support wsdl:required attributes since there is no SOAP extension mechanism in PHP. You will retrieve this exception: \"[SoapFault] SOAP-ERROR: Parsing WSDL: Unknown required WSDL extension\" when the WSDL does contain required SOAP extensions. This middleware can be used to set the \"wsdl:required\" property to false on the fly so that you don't have to change the WSDL on the server. Usage $wsdlProvier = HttPlugWsdlProvider::create($client); $wsdlProvider- addMiddleware(new DisableExtensionsMiddleware()); $clientBuilder- withWsdlProvider($wsdlProvider);","title":"Wsdl/DisableExtensionsMiddleware"},{"location":"middlewares/#creating-your-own-middleware","text":"Didn't find the middleware you needed? No worries! It is very easy to create your own middleware. We currently added a thin layer above HTTPlug plugins to make it easy to modify PSR-7 request and responses. The easiest way to get you starting is by extending the base Middleware class. You can specify your own beforeRequest() and afterResponse() method and manipulate whatever you like. class MyMiddleware extends \\Phpro\\SoapClient\\Middleware\\MiddleWare { public function getName(): string { return 'my_unique_middleware_name'; } /** * @param callable $handler * @param RequestInterface $request * @param array $options * * @return PromiseInterface */ public function beforeRequest(callable $handler, RequestInterface $request): Promise { return $handler($request, $options); } /** * @param ResponseInterface $response * * @return ResponseInterface */ public function afterResponse(ResponseInterface $response): ResponseInterface { return $response; } }","title":"Creating your own middleware"},{"location":"middlewares/#xml-manipulations","text":"Once you get a hang of creating your own middlewares, you'll find out that in many cases you need to manipulate the SOAP XML request or response. Because this XML is heavily namespaced, we created a SoapXml manipulator class. Example usage: // Load the XML from a PSR7 request or response: $xml = SoapXml::fromStream($request- getBody()); // Fetch specific elements: $dom = $xml- getXmlDocument(); $enveloppe = $xml- getEnvelope(); $headers = $xml- getHeaders(); $body = $xml- getBody(); $namespace = $xml- getSoapNamespaceUri(); // XML manipulations: $xml- addEnvelopeNamespace('alias', 'http://alias'); $newHeader = $xml- createSoapHeader(); $xml- prependSoapHeader($newHeader); // Xpath functions: $xml- registerNamespace('alias', 'http://alias'); $xml- xpath('/soap:Envelope')- item(0); // Use the manipulated XML in your PSR7 request or response: $request = $request- withBody($xml- toStream()) As you can see, this XML manipulation class is rather small at the moment but is super powerful. Internally it uses DOMDocument to make it possible to manipulate every little XML detail you want.","title":"XML manipulations"},{"location":"testing/","text":"Testing As mentioned earlier, it is very easy to integrate this project with php-vcr . This makes it possible to created fixtures of all your SOAP calls. By loading the fixtures, no actual calls will be done to the SOAP endpoint. This will make your tests fast, deterministic and accurate! Her is an example of a PHPUnit test: /** * @test * @vcr my-fixture-file.yml * */ function it_should_greet() { $response = $this- client- helloWorld(new HelloWorldRequest('name')); $this- assertEquals('Hello name', $response- getGreeting()); } The first time you run this test, a fixtures file my-fixture-file.yml will be created. The second time, this file will be used instead of running actual requests. Test it out, you will love it! Configuration \\VCR\\VCR::configure() - setCassettePath('test/fixtures/vcr') - enableLibraryHooks(['soap', 'curl']) ; \\VCR\\VCR::turnOn(); The configuration of php-vcr looks like this. Make sure to only select the library hook you wish to use. If you are using another handler then the default SoapHandle , you might only want to enable curl. The php-vcr package will overwrite the SoapClient which may result in custom methods that cannot be found.","title":"Testing"},{"location":"testing/#testing","text":"As mentioned earlier, it is very easy to integrate this project with php-vcr . This makes it possible to created fixtures of all your SOAP calls. By loading the fixtures, no actual calls will be done to the SOAP endpoint. This will make your tests fast, deterministic and accurate! Her is an example of a PHPUnit test: /** * @test * @vcr my-fixture-file.yml * */ function it_should_greet() { $response = $this- client- helloWorld(new HelloWorldRequest('name')); $this- assertEquals('Hello name', $response- getGreeting()); } The first time you run this test, a fixtures file my-fixture-file.yml will be created. The second time, this file will be used instead of running actual requests. Test it out, you will love it!","title":"Testing"},{"location":"testing/#configuration","text":"\\VCR\\VCR::configure() - setCassettePath('test/fixtures/vcr') - enableLibraryHooks(['soap', 'curl']) ; \\VCR\\VCR::turnOn(); The configuration of php-vcr looks like this. Make sure to only select the library hook you wish to use. If you are using another handler then the default SoapHandle , you might only want to enable curl. The php-vcr package will overwrite the SoapClient which may result in custom methods that cannot be found.","title":"Configuration"},{"location":"type-converter/","text":"Convert SOAP types Some exotic XSD types are hard to transform to PHP objects. A typical example are dates: some people like it as a timestamp, some want it as a DateTime, ... By adding custom TypeConverters, it is possible to convert a WSDL type to / from a PHP type. These TypeConverters are added by default: DateTimeTypeConverter DateTypeConverter DoubleTypeConverter DecimalTypeConverter You can also create your own converter by implementing the TypeConverterInterface . For example: class MyCustomConverter implements TypeConverterInterface { // Implement methods... }","title":"Convert SOAP types"},{"location":"type-converter/#convert-soap-types","text":"Some exotic XSD types are hard to transform to PHP objects. A typical example are dates: some people like it as a timestamp, some want it as a DateTime, ... By adding custom TypeConverters, it is possible to convert a WSDL type to / from a PHP type. These TypeConverters are added by default: DateTimeTypeConverter DateTypeConverter DoubleTypeConverter DecimalTypeConverter You can also create your own converter by implementing the TypeConverterInterface . For example: class MyCustomConverter implements TypeConverterInterface { // Implement methods... }","title":"Convert SOAP types"},{"location":"usage/","text":"Basic Usage Now that we explained all parts of your new SoapClient, it is time to interact with it. Look at following snippet: $wsdl = 'http://path.to/your.wsdl'; $clientFactory = new ClientFactory(YourClient::class); $soapOptions = [ 'cache_wsdl' = WSDL_CACHE_NONE ]; $clientBuilder = new ClientBuilder($clientFactory, $wsdl, $soapOptions); $clientBuilder- withLogger(new Logger()); $clientBuilder- withEventDispatcher(new EventDispatcher()); $clientBuilder- addClassMap(new ClassMap('WsdlType', PhpType::class)); $clientBuilder- addTypeConverter(new DateTimeTypeConverter()); $client = $clientBuilder- build(); $response = $client- helloWorld(new HelloWorldRequest('name')); echo $response- getGreeting(); Note: The Logger class is not provided by this package, use any PSR-3 compatible logger here (i.e. monolog). In the first part of the snippet you can see the global configuration of your own SOAP client. The YourClient class will be instantiated by a ClientFactory , which is responsible for injecting the client dependencies. It is possible to use the same Client with different WSDL endpoints and SOAP options. This makes it easy for changing between environments. Next, the client will be configured by the ClientBuilder . As you can see it is possible to add a Logger, EventDispatcher, Classmaps and TypeConverters. This makes the Soap client fully configurable. In the last part of the snippet you can see how the client works. It will use the generated value-objects to call the RequestInterface on the SoapClient. As a result the ResultProviderInterface will return the actual ResultInterface which contains the getGreeting() method. Readable, right? A client implements a single WSDL, so when the service you are implementing has multiple WSDL's then you'll need to create a client for each of the WSDL's you want to use. You can then manually create a wrapper class if you desire to do so.","title":"Basic Usage"},{"location":"usage/#basic-usage","text":"Now that we explained all parts of your new SoapClient, it is time to interact with it. Look at following snippet: $wsdl = 'http://path.to/your.wsdl'; $clientFactory = new ClientFactory(YourClient::class); $soapOptions = [ 'cache_wsdl' = WSDL_CACHE_NONE ]; $clientBuilder = new ClientBuilder($clientFactory, $wsdl, $soapOptions); $clientBuilder- withLogger(new Logger()); $clientBuilder- withEventDispatcher(new EventDispatcher()); $clientBuilder- addClassMap(new ClassMap('WsdlType', PhpType::class)); $clientBuilder- addTypeConverter(new DateTimeTypeConverter()); $client = $clientBuilder- build(); $response = $client- helloWorld(new HelloWorldRequest('name')); echo $response- getGreeting(); Note: The Logger class is not provided by this package, use any PSR-3 compatible logger here (i.e. monolog). In the first part of the snippet you can see the global configuration of your own SOAP client. The YourClient class will be instantiated by a ClientFactory , which is responsible for injecting the client dependencies. It is possible to use the same Client with different WSDL endpoints and SOAP options. This makes it easy for changing between environments. Next, the client will be configured by the ClientBuilder . As you can see it is possible to add a Logger, EventDispatcher, Classmaps and TypeConverters. This makes the Soap client fully configurable. In the last part of the snippet you can see how the client works. It will use the generated value-objects to call the RequestInterface on the SoapClient. As a result the ResultProviderInterface will return the actual ResultInterface which contains the getGreeting() method. Readable, right? A client implements a single WSDL, so when the service you are implementing has multiple WSDL's then you'll need to create a client for each of the WSDL's you want to use. You can then manually create a wrapper class if you desire to do so.","title":"Basic Usage"},{"location":"wsdl-providers/","text":"Get in control of the WSDL file The built-in SOAP client does not give you control on how the WSDL is downloaded to the system. Therefor we've created a WsdlProvider mechanism that can be customized to your demands. General configuration: $clientBuilder = new ClientBuilder($clientFactory, $wsdl, $soapOptions); $clientBuilder- withWsdlProvider($provider); $client = $clientBuilder- build(); Here is a list of built-in providers: HttPlugWsdlProvider InMemoryWsdlProvider LocalWsdlProvider MixedWsdlProvider Can't find the wsdl provider you were looking for? It is always possible to create your own one! HttPlugWsdlProvider HTTPlug is a HTTP client abstraction that can be used with multiple client packages. The HTTPlug WSDL provider can be used for downloading remote WSDLs. It has support for middlewares so that you have full control over the HTTP request and response. This way, you will always be able to download and manipulate the WSDL file even if it secured with e.g. NTLM. Dependencies Load HTTP plug core packages: composer require psr/http-message:^1.0 php-http/httplug:^1.1 php-http/message-factory:^1.0 php-http/discovery:^1.3 php-http/message:^1.6 php-http/client-common:^1.6 Select HTTP Client Select one of the many clients you want to use to perform the HTTP requests: http://docs.php-http.org/en/latest/clients.html#clients-adapters composer require php-http/client-implementation:^1.0 Configuration $provider = HttPlugWsdlProvider::createForClient($client); // Optional location: $provider- setLocation('/some/destination/file.wsdl'); // Middlewares support: $provider- addMiddleware($middleware); // Register to the client builder $clientBuilder = new ClientBuilder($clientFactory, $wsdl, $soapOptions); $clientBuilder- withWsdlProvider($provider); $client = $clientBuilder- build(); Note: If you want to cache the WSDL so that you don't have to download it on every request, you can use the built-in caching options: $clientBuilder = new ClientBuilder($clientFactory, $wsdl, [ 'cache_wsdl' = WSDL_CACHE_BOTH, ]); To change the TTL of the cache, you can adjust following php.ini setting: # See: http://php.net/manual/en/soap.configuration.php soap.wsdl_cache_ttl: 86400 InMemoryWsdlProvider By using the in-memory WSDL provider, you can just use a complete XML version of the WSDL as source. This one might come in handy during tests, but probably shouldn't be used in production. Configuration $wsdl = ' definitions ..... / ' $clientBuilder = new ClientBuilder($clientFactory, $wsdl, $soapOptions); $clientBuilder- withWsdlProvider(new InMemoryWsdlProvider()); $client = $clientBuilder- build(); LocalWsdlProvider The local WSDL provider can be used to load a local file. It contains an additional check to make sure that the WSDL file exists and throws a WsdlException if it does not exist. Configuration $clientBuilder = new ClientBuilder($clientFactory, $wsdl, $soapOptions); $clientBuilder- withWsdlProvider(LocalWsdlProvider::create()); $client = $clientBuilder- build(); MixedWsdlProvider The mixed WSDL provider is used by default. You can pass every string you would normally pass to the built-in SOAP client's wsdl option. No additional checks are executed, the loading of the file will be handled by the internal SoapClient class. Configuration $clientBuilder = new ClientBuilder($clientFactory, $wsdl, $soapOptions); $clientBuilder- withWsdlProvider(new MixedWsdlProvider()); $client = $clientBuilder- build(); Creating your own WSDL provider Didn't find the WSDL provider you needed? No worries! It is very easy to create your own WSDL provider. The only thing you'll need to do is implement the WsdlProviderInterface: class MyWsdlProvider extends \\Phpro\\SoapClient\\Wsdl\\Provider\\WsdlProviderInterface { /** * The result of this method should be the link to the WSDL that can be used by the PHP soap-client. * * {@inheritdoc} */ public function provide(string $source) { return $source; } }","title":"Get in control of the WSDL file"},{"location":"wsdl-providers/#get-in-control-of-the-wsdl-file","text":"The built-in SOAP client does not give you control on how the WSDL is downloaded to the system. Therefor we've created a WsdlProvider mechanism that can be customized to your demands. General configuration: $clientBuilder = new ClientBuilder($clientFactory, $wsdl, $soapOptions); $clientBuilder- withWsdlProvider($provider); $client = $clientBuilder- build(); Here is a list of built-in providers: HttPlugWsdlProvider InMemoryWsdlProvider LocalWsdlProvider MixedWsdlProvider Can't find the wsdl provider you were looking for? It is always possible to create your own one!","title":"Get in control of the WSDL file"},{"location":"wsdl-providers/#httplugwsdlprovider","text":"HTTPlug is a HTTP client abstraction that can be used with multiple client packages. The HTTPlug WSDL provider can be used for downloading remote WSDLs. It has support for middlewares so that you have full control over the HTTP request and response. This way, you will always be able to download and manipulate the WSDL file even if it secured with e.g. NTLM. Dependencies Load HTTP plug core packages: composer require psr/http-message:^1.0 php-http/httplug:^1.1 php-http/message-factory:^1.0 php-http/discovery:^1.3 php-http/message:^1.6 php-http/client-common:^1.6 Select HTTP Client Select one of the many clients you want to use to perform the HTTP requests: http://docs.php-http.org/en/latest/clients.html#clients-adapters composer require php-http/client-implementation:^1.0 Configuration $provider = HttPlugWsdlProvider::createForClient($client); // Optional location: $provider- setLocation('/some/destination/file.wsdl'); // Middlewares support: $provider- addMiddleware($middleware); // Register to the client builder $clientBuilder = new ClientBuilder($clientFactory, $wsdl, $soapOptions); $clientBuilder- withWsdlProvider($provider); $client = $clientBuilder- build(); Note: If you want to cache the WSDL so that you don't have to download it on every request, you can use the built-in caching options: $clientBuilder = new ClientBuilder($clientFactory, $wsdl, [ 'cache_wsdl' = WSDL_CACHE_BOTH, ]); To change the TTL of the cache, you can adjust following php.ini setting: # See: http://php.net/manual/en/soap.configuration.php soap.wsdl_cache_ttl: 86400","title":"HttPlugWsdlProvider"},{"location":"wsdl-providers/#inmemorywsdlprovider","text":"By using the in-memory WSDL provider, you can just use a complete XML version of the WSDL as source. This one might come in handy during tests, but probably shouldn't be used in production. Configuration $wsdl = ' definitions ..... / ' $clientBuilder = new ClientBuilder($clientFactory, $wsdl, $soapOptions); $clientBuilder- withWsdlProvider(new InMemoryWsdlProvider()); $client = $clientBuilder- build();","title":"InMemoryWsdlProvider"},{"location":"wsdl-providers/#localwsdlprovider","text":"The local WSDL provider can be used to load a local file. It contains an additional check to make sure that the WSDL file exists and throws a WsdlException if it does not exist. Configuration $clientBuilder = new ClientBuilder($clientFactory, $wsdl, $soapOptions); $clientBuilder- withWsdlProvider(LocalWsdlProvider::create()); $client = $clientBuilder- build();","title":"LocalWsdlProvider"},{"location":"wsdl-providers/#mixedwsdlprovider","text":"The mixed WSDL provider is used by default. You can pass every string you would normally pass to the built-in SOAP client's wsdl option. No additional checks are executed, the loading of the file will be handled by the internal SoapClient class. Configuration $clientBuilder = new ClientBuilder($clientFactory, $wsdl, $soapOptions); $clientBuilder- withWsdlProvider(new MixedWsdlProvider()); $client = $clientBuilder- build();","title":"MixedWsdlProvider"},{"location":"wsdl-providers/#creating-your-own-wsdl-provider","text":"Didn't find the WSDL provider you needed? No worries! It is very easy to create your own WSDL provider. The only thing you'll need to do is implement the WsdlProviderInterface: class MyWsdlProvider extends \\Phpro\\SoapClient\\Wsdl\\Provider\\WsdlProviderInterface { /** * The result of this method should be the link to the WSDL that can be used by the PHP soap-client. * * {@inheritdoc} */ public function provide(string $source) { return $source; } }","title":"Creating your own WSDL provider"},{"location":"cli/generate-classmap/","text":"Generating class maps Before you can generate code, you'll need to add some additional dev dependencies to your project: composer require --dev zendframework/zend-code:^3.1.0 When the value-objects are generated, we need to tell SOAP about how the PHP classes are mapped to the XSD types. This is done by a class map, which can be a really boring manual task. Luckily a class map generator is added, which you can use to parse the classmap from the WSDL. $ ./vendor/bin/soap-client generate:classmap [16:13:31] Usage: generate:classmap [options] Options: --config=CONFIG The location of the soap code-generator config file -o, --overwrite Makes it possible to overwrite by default -h, --help Display this help message -q, --quiet Do not output any message -V, --version Display this application version --ansi Force ANSI output --no-ansi Disable ANSI output -n, --no-interaction Do not ask any interactive question -v|vv|vvv, --verbose Increase the verbosity of messages: 1 for normal output, 2 for more verbose output and 3 for debug To generate a classmap, following values need to be set in your config: - setClassMapName('MyClassmap') - setClassMapNamespace('Myapp\\\\MyclassMap') - setClassMapDestination('src/myapp/myclassmap') Where the name is the class name you want to give your classmap, the namespace is where this class should reside in and the destination in the relative path from the project root where the file should be put. Options: config : A configuration file is required to build the classmap. Example output: ?php namespace Myapp\\Example\\Classmap; use ... class OrderClassMap { public static function getCollection() : \\Phpro\\SoapClient\\Soap\\ClassMap\\ClassMapCollection { return new ClassMapCollection([ new ClassMap('CreateOrder', Type\\Example1::class), new ClassMap('CardOrder', Type\\Example2::class), new ClassMap('OrderDetails', Type\\Example3::class) ]); } }","title":"Generating class maps"},{"location":"cli/generate-classmap/#generating-class-maps","text":"Before you can generate code, you'll need to add some additional dev dependencies to your project: composer require --dev zendframework/zend-code:^3.1.0 When the value-objects are generated, we need to tell SOAP about how the PHP classes are mapped to the XSD types. This is done by a class map, which can be a really boring manual task. Luckily a class map generator is added, which you can use to parse the classmap from the WSDL. $ ./vendor/bin/soap-client generate:classmap [16:13:31] Usage: generate:classmap [options] Options: --config=CONFIG The location of the soap code-generator config file -o, --overwrite Makes it possible to overwrite by default -h, --help Display this help message -q, --quiet Do not output any message -V, --version Display this application version --ansi Force ANSI output --no-ansi Disable ANSI output -n, --no-interaction Do not ask any interactive question -v|vv|vvv, --verbose Increase the verbosity of messages: 1 for normal output, 2 for more verbose output and 3 for debug To generate a classmap, following values need to be set in your config: - setClassMapName('MyClassmap') - setClassMapNamespace('Myapp\\\\MyclassMap') - setClassMapDestination('src/myapp/myclassmap') Where the name is the class name you want to give your classmap, the namespace is where this class should reside in and the destination in the relative path from the project root where the file should be put. Options: config : A configuration file is required to build the classmap. Example output: ?php namespace Myapp\\Example\\Classmap; use ... class OrderClassMap { public static function getCollection() : \\Phpro\\SoapClient\\Soap\\ClassMap\\ClassMapCollection { return new ClassMapCollection([ new ClassMap('CreateOrder', Type\\Example1::class), new ClassMap('CardOrder', Type\\Example2::class), new ClassMap('OrderDetails', Type\\Example3::class) ]); } }","title":"Generating class maps"},{"location":"cli/generate-client/","text":"Generating clients Before you can generate code, you'll need to add some additional dev dependencies to your project: composer require --dev zendframework/zend-code:^3.1.0 A client with type and return type hints can be generated. $ ./vendor/bin/soap-client generate:client [16:13:31] Usage: generate:client [options] Options: --config=CONFIG The location of the soap code-generator config file This command will generate a client based on the client setings in the configuration. This client will contain all methods used to initiate calls and uses type hinted parameters and return types. Options: config : A configuration file is required to build the classmap.","title":"Generating clients"},{"location":"cli/generate-client/#generating-clients","text":"Before you can generate code, you'll need to add some additional dev dependencies to your project: composer require --dev zendframework/zend-code:^3.1.0 A client with type and return type hints can be generated. $ ./vendor/bin/soap-client generate:client [16:13:31] Usage: generate:client [options] Options: --config=CONFIG The location of the soap code-generator config file This command will generate a client based on the client setings in the configuration. This client will contain all methods used to initiate calls and uses type hinted parameters and return types. Options: config : A configuration file is required to build the classmap.","title":"Generating clients"},{"location":"cli/generate-clientfactory/","text":"Generate a base client factory To make things a little easier to get started a client factory generator method is available. vendor/bin/soap-client generate:clientfactory Usage: generate:clientfactory [options] Options: --config=CONFIG The location of the soap code-generator config file -o, --overwrite Makes it possible to overwrite by default -h, --help Display this help message -q, --quiet Do not output any message -V, --version Display this application version --ansi Force ANSI output --no-ansi Disable ANSI output -n, --no-interaction Do not ask any interactive question -v|vv|vvv, --verbose Increase the verbosity of messages: 1 for normal output, 2 for more verbose output and 3 for debug Options: config : A configuration file is required to build the classmap. The factory will be put in the same namespace and directory as the client, and use the same name as the client, appended by Factory. Example output: ?php namespace App\\Client; use App\\Client\\Client; use App\\Order\\OrderClassmap; use Phpro\\SoapClient\\ClientFactory as PhproClientFactory; use Phpro\\SoapClient\\ClientBuilder; class ClientFactory { public static function factory(string $wsdl) : \\App\\Client { $clientFactory = new PhproClientFactory(Client::class); $clientBuilder = new ClientBuilder($clientFactory, $wsdl, []); $clientBuilder- withClassMaps(OrderClassmap::getCollection()); return $clientBuilder- build(); } } You can then tweak this class to fit your needs.","title":"Generate a base client factory"},{"location":"cli/generate-clientfactory/#generate-a-base-client-factory","text":"To make things a little easier to get started a client factory generator method is available. vendor/bin/soap-client generate:clientfactory Usage: generate:clientfactory [options] Options: --config=CONFIG The location of the soap code-generator config file -o, --overwrite Makes it possible to overwrite by default -h, --help Display this help message -q, --quiet Do not output any message -V, --version Display this application version --ansi Force ANSI output --no-ansi Disable ANSI output -n, --no-interaction Do not ask any interactive question -v|vv|vvv, --verbose Increase the verbosity of messages: 1 for normal output, 2 for more verbose output and 3 for debug Options: config : A configuration file is required to build the classmap. The factory will be put in the same namespace and directory as the client, and use the same name as the client, appended by Factory. Example output: ?php namespace App\\Client; use App\\Client\\Client; use App\\Order\\OrderClassmap; use Phpro\\SoapClient\\ClientFactory as PhproClientFactory; use Phpro\\SoapClient\\ClientBuilder; class ClientFactory { public static function factory(string $wsdl) : \\App\\Client { $clientFactory = new PhproClientFactory(Client::class); $clientBuilder = new ClientBuilder($clientFactory, $wsdl, []); $clientBuilder- withClassMaps(OrderClassmap::getCollection()); return $clientBuilder- build(); } } You can then tweak this class to fit your needs.","title":"Generate a base client factory"},{"location":"cli/generate-types/","text":"Generating Value-objects Before you can generate code, you'll need to add some additional dev dependencies to your project: composer require --dev zendframework/zend-code:^3.1.0 Basic value-objects can be generated automatically. $ ./vendor/bin/soap-client generate:types [16:13:38] Usage: generate:types [options] Options: --config=CONFIG The location of the soap code-generator config file -o, --overwrite Makes it possible to overwrite by default This generator will read all XSD types from the provided WSDL and convert it to PHP classes. You can specify a namespace and a location where the classes will be stored. The properties from the XSD will be added as protected properties to the value-objects. When the classes already exist, a patch operation is performed and a backup file is created. This way your custom code will always remain available. Keep in mind that the WSDL must provide all XSD types for the generation of value-objects. Some exotic SOAP services don't provide much information. For example: they will return an XML string which needs to be parsed manually. These WSDLs can only be parsed as far as the XSD information goes. Al other information needs to be added manually, or by a custom class generator. Options: config : A configuration file is required to build the types. overwrite : The soap-client overrides a file that cannot be patched without asking for confirmation. When the value objects are generated, you will still need to customize them. For example by adding the required interfaces: class HelloWorldRequest implements RequestInterface { public function __construct($name) { $this- name = $name } // Generated code } class HelloWorldResponse implements ResponseProviderInterface { // Generated code public function getResponse() { return $this- greeting; } } class Greeting implements ResponseInterface { // Generated code public function getGreeting() { return $this- greeting; } } This can be done by specifying some code generation rules and assemblers .","title":"Generating Value-objects"},{"location":"cli/generate-types/#generating-value-objects","text":"Before you can generate code, you'll need to add some additional dev dependencies to your project: composer require --dev zendframework/zend-code:^3.1.0 Basic value-objects can be generated automatically. $ ./vendor/bin/soap-client generate:types [16:13:38] Usage: generate:types [options] Options: --config=CONFIG The location of the soap code-generator config file -o, --overwrite Makes it possible to overwrite by default This generator will read all XSD types from the provided WSDL and convert it to PHP classes. You can specify a namespace and a location where the classes will be stored. The properties from the XSD will be added as protected properties to the value-objects. When the classes already exist, a patch operation is performed and a backup file is created. This way your custom code will always remain available. Keep in mind that the WSDL must provide all XSD types for the generation of value-objects. Some exotic SOAP services don't provide much information. For example: they will return an XML string which needs to be parsed manually. These WSDLs can only be parsed as far as the XSD information goes. Al other information needs to be added manually, or by a custom class generator. Options: config : A configuration file is required to build the types. overwrite : The soap-client overrides a file that cannot be patched without asking for confirmation. When the value objects are generated, you will still need to customize them. For example by adding the required interfaces: class HelloWorldRequest implements RequestInterface { public function __construct($name) { $this- name = $name } // Generated code } class HelloWorldResponse implements ResponseProviderInterface { // Generated code public function getResponse() { return $this- greeting; } } class Greeting implements ResponseInterface { // Generated code public function getGreeting() { return $this- greeting; } } This can be done by specifying some code generation rules and assemblers .","title":"Generating Value-objects"},{"location":"code-generation/assemblers/","text":"Code assemblers Code assemblers are a thin layer above zend-code . There are a lot of built-in assemblers but it is also possible to create your own assembler to generate the code you want to add to the generated SOAP types. Built-in assemblers ClassMapAssembler ConstructorAssembler ExtendAssembler FinalClassAssembler FluentSetterAssembler GetterAssembler ImmutableSetterAssembler InterfaceAssembler IteratorAssembler JsonSerializableAssembler PropertyAssembler RequestAssembler ResultAssembler ResultProviderAssembler SetterAssembler TraitAssembler UseAssembler ClassMapAssembler The ClassMapAssembler is activated by default and is used during the generate:classmap command. Example output: ?php use Phpro\\SoapClient\\Soap\\ClassMap\\ClassMapCollection; use Phpro\\SoapClient\\Soap\\ClassMap\\ClassMap; new ClassMapCollection([ new ClassMap('HelloWorldRequest', \\HelloWorldRequest::class), new ClassMap('HelloWorldResponse', \\HelloWorldResponse::class), new ClassMap('Greeting', \\Greeting::class), ]); ConstructorAssembler The `ConstructorAssembler can be used to add a constructor with all the class properties to the generated class. Example output: /** * Constructor * * @var string $prop1 * @var int $prop2 */ public function __construct($prop1, $prop2) { $this- prop1 = $prop1; $this- prop2 = $prop2; } FluentSetterAssembler The FluentSetterAssembler will add a setter method to the generated class. The method will return the current instance to enable chaining. Example output: /** * @param string $prop1 * @return $this */ public function setProp1($prop1) { $this- prop1 = $prop1; return $this; } Generating type-hints is disabled by default, but can be enabled by passing FluentSetterAssemblerOption instance to the constructor with the option withTypeHints set to true. Example new FluentSetterAssembler((new FluentSetterAssemblerOptions())- withTypeHints()) /** * @param string $prop1 * @return $this */ public function setProp1(string $prop1) { $this- prop1 = $prop1; return $this; } FinalClassAssembler The FinalClassAssembler can be used to mark a generated class as final. Example output: final class MyType { } ExtendAssembler The ExtendAssembler will add a parent class to the generated class. Example output: class MyType extends DType { } GetterAssembler The GetterAssembler will add a getter method to the generated class. For boolean types you can opt to use the 'is' function prefix instead of 'get' by enabling this in the constructor. Example output: /** * @return string */ public function getProp1() { return $this- prop1; } This assembler needs to be constructed with an instance of GetterAssemblerOptions InterfaceAssembler The InterfaceAssembler can be used to add a specific interface to the generated class. Example output: use Iterator; class MyType implements Iterator { } IteratorAssembler The IteratorAssembler can be used for SOAP types that contain a list of another SOAP type. This assembler will make it easy to iterate over the types. Example output: use IteratorAggregate; class MyType implements IteratorAggregate { /** * @return \\ArrayIterator */ public function getIterator() { return new \\ArrayIterator(is_array($this- prop1) ? $this- prop1 : []); } } JsonSerializableAssembler The JsonSerializableAssembler can be used if you want to JSON serialize your SOAP objects. This could be handy for logging JSON serialized request / response data which makes your logs smaller. Example output: use JsonSerializable; class MyType implements JsonSerializable { /** * @return array */ public function jsonSerialize() { return [ 'prop1' = \\$this- prop1, 'prop2' = \\$this- prop2, ]; } } PropertyAssembler This PropertyAssembler is enabled by default and is used during the generate:types command. Example output: /** * @var string */ private $prop1 = null; You can adjust the visibility of the property by injecting the visibility in the constructor. new PropertyAssembler(PropertyGenerator::VISIBILITY_PROTECTED) Please note that the default ruleset has a visibility of private. If you want to override this, you will have to override all rules by calling Phpro\\SoapClient\\CodeGenerator\\Config\\Config::setRuleSet . RequestAssembler The RequestAssembler can be used to add the RequestInterface to a generated class. Example output: use Phpro\\SoapClient\\Type\\RequestInterface; class MyType implements RequestInterface { } ResultAssembler The ResultAssembler can be used to add the ResultInterface to a generated class. Example output: use Phpro\\SoapClient\\Type\\ResultInterface; class MyType implements ResultInterface { } ResultProviderAssembler The ResultProviderAssembler can be used to add the ResultProviderInterface to a generated class. Example output: use Phpro\\SoapClient\\Type\\ResultProviderInterface; use Phpro\\SoapClient\\Type\\ResultInterface; class MyType implements ResultProviderInterface { /** * @return SomeClass|ResultInterface */ public function getResult() : \\Phpro\\SoapClient\\Type\\ResultInterface { return $this- prop1; } } It is also possible to add an optional wrapperClass to the constructor. This way, the result is wrapped with a class you specified. Example output: namespace MyNamespace; use Phpro\\SoapClient\\Type\\ResultProviderInterface; use Phpro\\SoapClient\\Type\\MixedResult class MyType implements ResultProviderInterface { /** * @return MixedResult */ public function getResult() : \\Phpro\\SoapClient\\Type\\ResultInterface { return new MixedResult($this- prop1); } } SetterAssembler The SetterAssembler will add a setter method to the generated class. Example output: /** * @param string $prop1 */ public function setProp1($prop1) { $this- prop1 = $prop1; } This assembler needs to be constructed with an instance of SetterAssemblerOptions . TraitAssembler The TraitAssembler can be used to add a specific trait to the generated class. An alias can be used by passing it in as second argument. Example output: use MyTrait; class MyType { use MyTrait } UseAssembler The UseAssembler can be used to add usage statements to the generated class. Often used internally to add uses for interfaces or traits. An alias can be used by passing it in as second argument. Example output: use MyTrait as TraitAlias; class MyType { } ImmutableSetterAssembler The ImmutableSetterAssembler generates immutable setters that return a new instance with the new value set. Used to create variations of the same base instance, without modifying the original values. Example output: /** * @param string $prop1 * @return MyType */ public function withProp1($prop1) { $new = clone $this; $new- prop1 = $prop1; return $new; } Creating your own Assembler Creating your own Assembler is pretty easy. The only thing you'll need to do is implementing the AssemblerInterface . You can use the zend-code ClassGenerator and FileGenerator to manipulate your code. /** * Interface AssemblerInterface * * @package Phpro\\SoapClient\\CodeGenerator\\Assembler */ interface AssemblerInterface { /** * @param ContextInterface $context * * @return bool */ public function canAssemble(ContextInterface $context); /** * Assembles pieces of code. * * @param ContextInterface $context * @throws AssemblerException */ public function assemble(ContextInterface $context); } Possible contexts: ClassMapContext : Triggered during the generate:classmap command. TypeContext : Triggered during the generate:types command for every type in the SOAP scheme. PropertyContext : Triggered during the generate:types command for every property in a SOAP type.","title":"Code assemblers"},{"location":"code-generation/assemblers/#code-assemblers","text":"Code assemblers are a thin layer above zend-code . There are a lot of built-in assemblers but it is also possible to create your own assembler to generate the code you want to add to the generated SOAP types.","title":"Code assemblers"},{"location":"code-generation/assemblers/#built-in-assemblers","text":"ClassMapAssembler ConstructorAssembler ExtendAssembler FinalClassAssembler FluentSetterAssembler GetterAssembler ImmutableSetterAssembler InterfaceAssembler IteratorAssembler JsonSerializableAssembler PropertyAssembler RequestAssembler ResultAssembler ResultProviderAssembler SetterAssembler TraitAssembler UseAssembler","title":"Built-in assemblers"},{"location":"code-generation/assemblers/#classmapassembler","text":"The ClassMapAssembler is activated by default and is used during the generate:classmap command. Example output: ?php use Phpro\\SoapClient\\Soap\\ClassMap\\ClassMapCollection; use Phpro\\SoapClient\\Soap\\ClassMap\\ClassMap; new ClassMapCollection([ new ClassMap('HelloWorldRequest', \\HelloWorldRequest::class), new ClassMap('HelloWorldResponse', \\HelloWorldResponse::class), new ClassMap('Greeting', \\Greeting::class), ]);","title":"ClassMapAssembler"},{"location":"code-generation/assemblers/#constructorassembler","text":"The `ConstructorAssembler can be used to add a constructor with all the class properties to the generated class. Example output: /** * Constructor * * @var string $prop1 * @var int $prop2 */ public function __construct($prop1, $prop2) { $this- prop1 = $prop1; $this- prop2 = $prop2; }","title":"ConstructorAssembler"},{"location":"code-generation/assemblers/#fluentsetterassembler","text":"The FluentSetterAssembler will add a setter method to the generated class. The method will return the current instance to enable chaining. Example output: /** * @param string $prop1 * @return $this */ public function setProp1($prop1) { $this- prop1 = $prop1; return $this; } Generating type-hints is disabled by default, but can be enabled by passing FluentSetterAssemblerOption instance to the constructor with the option withTypeHints set to true. Example new FluentSetterAssembler((new FluentSetterAssemblerOptions())- withTypeHints()) /** * @param string $prop1 * @return $this */ public function setProp1(string $prop1) { $this- prop1 = $prop1; return $this; }","title":"FluentSetterAssembler"},{"location":"code-generation/assemblers/#finalclassassembler","text":"The FinalClassAssembler can be used to mark a generated class as final. Example output: final class MyType { }","title":"FinalClassAssembler"},{"location":"code-generation/assemblers/#extendassembler","text":"The ExtendAssembler will add a parent class to the generated class. Example output: class MyType extends DType { }","title":"ExtendAssembler"},{"location":"code-generation/assemblers/#getterassembler","text":"The GetterAssembler will add a getter method to the generated class. For boolean types you can opt to use the 'is' function prefix instead of 'get' by enabling this in the constructor. Example output: /** * @return string */ public function getProp1() { return $this- prop1; } This assembler needs to be constructed with an instance of GetterAssemblerOptions","title":"GetterAssembler"},{"location":"code-generation/assemblers/#interfaceassembler","text":"The InterfaceAssembler can be used to add a specific interface to the generated class. Example output: use Iterator; class MyType implements Iterator { }","title":"InterfaceAssembler"},{"location":"code-generation/assemblers/#iteratorassembler","text":"The IteratorAssembler can be used for SOAP types that contain a list of another SOAP type. This assembler will make it easy to iterate over the types. Example output: use IteratorAggregate; class MyType implements IteratorAggregate { /** * @return \\ArrayIterator */ public function getIterator() { return new \\ArrayIterator(is_array($this- prop1) ? $this- prop1 : []); } }","title":"IteratorAssembler"},{"location":"code-generation/assemblers/#jsonserializableassembler","text":"The JsonSerializableAssembler can be used if you want to JSON serialize your SOAP objects. This could be handy for logging JSON serialized request / response data which makes your logs smaller. Example output: use JsonSerializable; class MyType implements JsonSerializable { /** * @return array */ public function jsonSerialize() { return [ 'prop1' = \\$this- prop1, 'prop2' = \\$this- prop2, ]; } }","title":"JsonSerializableAssembler"},{"location":"code-generation/assemblers/#propertyassembler","text":"This PropertyAssembler is enabled by default and is used during the generate:types command. Example output: /** * @var string */ private $prop1 = null; You can adjust the visibility of the property by injecting the visibility in the constructor. new PropertyAssembler(PropertyGenerator::VISIBILITY_PROTECTED) Please note that the default ruleset has a visibility of private. If you want to override this, you will have to override all rules by calling Phpro\\SoapClient\\CodeGenerator\\Config\\Config::setRuleSet .","title":"PropertyAssembler"},{"location":"code-generation/assemblers/#requestassembler","text":"The RequestAssembler can be used to add the RequestInterface to a generated class. Example output: use Phpro\\SoapClient\\Type\\RequestInterface; class MyType implements RequestInterface { }","title":"RequestAssembler"},{"location":"code-generation/assemblers/#resultassembler","text":"The ResultAssembler can be used to add the ResultInterface to a generated class. Example output: use Phpro\\SoapClient\\Type\\ResultInterface; class MyType implements ResultInterface { }","title":"ResultAssembler"},{"location":"code-generation/assemblers/#resultproviderassembler","text":"The ResultProviderAssembler can be used to add the ResultProviderInterface to a generated class. Example output: use Phpro\\SoapClient\\Type\\ResultProviderInterface; use Phpro\\SoapClient\\Type\\ResultInterface; class MyType implements ResultProviderInterface { /** * @return SomeClass|ResultInterface */ public function getResult() : \\Phpro\\SoapClient\\Type\\ResultInterface { return $this- prop1; } } It is also possible to add an optional wrapperClass to the constructor. This way, the result is wrapped with a class you specified. Example output: namespace MyNamespace; use Phpro\\SoapClient\\Type\\ResultProviderInterface; use Phpro\\SoapClient\\Type\\MixedResult class MyType implements ResultProviderInterface { /** * @return MixedResult */ public function getResult() : \\Phpro\\SoapClient\\Type\\ResultInterface { return new MixedResult($this- prop1); } }","title":"ResultProviderAssembler"},{"location":"code-generation/assemblers/#setterassembler","text":"The SetterAssembler will add a setter method to the generated class. Example output: /** * @param string $prop1 */ public function setProp1($prop1) { $this- prop1 = $prop1; } This assembler needs to be constructed with an instance of SetterAssemblerOptions .","title":"SetterAssembler"},{"location":"code-generation/assemblers/#traitassembler","text":"The TraitAssembler can be used to add a specific trait to the generated class. An alias can be used by passing it in as second argument. Example output: use MyTrait; class MyType { use MyTrait }","title":"TraitAssembler"},{"location":"code-generation/assemblers/#useassembler","text":"The UseAssembler can be used to add usage statements to the generated class. Often used internally to add uses for interfaces or traits. An alias can be used by passing it in as second argument. Example output: use MyTrait as TraitAlias; class MyType { }","title":"UseAssembler"},{"location":"code-generation/assemblers/#immutablesetterassembler","text":"The ImmutableSetterAssembler generates immutable setters that return a new instance with the new value set. Used to create variations of the same base instance, without modifying the original values. Example output: /** * @param string $prop1 * @return MyType */ public function withProp1($prop1) { $new = clone $this; $new- prop1 = $prop1; return $new; }","title":"ImmutableSetterAssembler"},{"location":"code-generation/assemblers/#creating-your-own-assembler","text":"Creating your own Assembler is pretty easy. The only thing you'll need to do is implementing the AssemblerInterface . You can use the zend-code ClassGenerator and FileGenerator to manipulate your code. /** * Interface AssemblerInterface * * @package Phpro\\SoapClient\\CodeGenerator\\Assembler */ interface AssemblerInterface { /** * @param ContextInterface $context * * @return bool */ public function canAssemble(ContextInterface $context); /** * Assembles pieces of code. * * @param ContextInterface $context * @throws AssemblerException */ public function assemble(ContextInterface $context); } Possible contexts: ClassMapContext : Triggered during the generate:classmap command. TypeContext : Triggered during the generate:types command for every type in the SOAP scheme. PropertyContext : Triggered during the generate:types command for every property in a SOAP type.","title":"Creating your own Assembler"},{"location":"code-generation/configuration/","text":"Configuration The code generation commands require a configuration file to determine how the SOAP classes need to be generated. ?php // my-soap-config.php use Phpro\\SoapClient\\CodeGenerator\\Config\\Config; use Phpro\\SoapClient\\CodeGenerator\\Rules; use Phpro\\SoapClient\\CodeGenerator\\Assembler; return Config::create() - setWsdl('http://localhost/path/to/soap.wsdl') - setTypeDestination('src/SoapTypes') - setTypeNamespace('SoapTypes') - setClientDestination('src/SoapClient') - setClientNamespace('SoapClient') - setClientName('MySoapClient') - setClassMapNamespace('Acme\\\\Classmap') - setClassMapDestination('src/acme/classmap') - setClassMapName('AcmeClassmap') - addSoapOption('features', SOAP_SINGLE_ELEMENT_ARRAYS) - addRule(new Rules\\AssembleRule(new Assembler\\GetterAssembler( (new Assembler\\GetterAssemblerOptions()) - withReturnType() - withBoolGetters() ))) - addRule(new Rules\\TypenameMatchesRule( new Rules\\AssembleRule(new Assembler\\RequestAssembler()), '/Request$/' )) - addRule(new Rules\\TypenameMatchesRule( new Rules\\AssembleRule(new Assembler\\ResultAssembler()), '/Response$/' )) ; Luckily a command is provided to generate this for you in an interactive manner. Execute vendor/bin/soap-client generate:config to start the interactive config generator. wsdl String - REQUIRED The full path the the WSDL file you want to parse type destination String - REQUIRED The destination of the generated PHP classes. client destination String - REQUIRED The destination of the generated soap client. soapOptions Array - OPTIONAL The soap options you want to add to the SoapClient during code generation. Default values: [ 'trace' = false, 'exceptions' = true, 'keep_alive' = true, 'cache_wsdl' = WSDL_CACHE_NONE, ] type namespace String - OPTIONAL The namespace of the PHP Classes you want to generate. client namespace String - OPTIONAL The namespace of the generated client. client name String - OPTIONAL The class name of the client, defaults to 'Client'. classmap name Name of the classmap class classmap destination The location of a directory the classmap should be generated in. classmap namespace Name for the classmap rules RuleInterface - OPTIONAL You can specify how you want to generate your code. More information about the topic is available in the rules and assemblers section. The pre-defined rules are override-able by calling setRuleSet on the constucted object. For example, to make all your properties protected: Config::create() - setRuleSet( new Rules\\RuleSet( [ new Rules\\AssembleRule(new Assembler\\PropertyAssembler(PropertyGenerator::VISIBILITY_PROTECTED)), new Rules\\AssembleRule(new Assembler\\ClassMapAssembler()), ] ) )","title":"Configuration"},{"location":"code-generation/configuration/#configuration","text":"The code generation commands require a configuration file to determine how the SOAP classes need to be generated. ?php // my-soap-config.php use Phpro\\SoapClient\\CodeGenerator\\Config\\Config; use Phpro\\SoapClient\\CodeGenerator\\Rules; use Phpro\\SoapClient\\CodeGenerator\\Assembler; return Config::create() - setWsdl('http://localhost/path/to/soap.wsdl') - setTypeDestination('src/SoapTypes') - setTypeNamespace('SoapTypes') - setClientDestination('src/SoapClient') - setClientNamespace('SoapClient') - setClientName('MySoapClient') - setClassMapNamespace('Acme\\\\Classmap') - setClassMapDestination('src/acme/classmap') - setClassMapName('AcmeClassmap') - addSoapOption('features', SOAP_SINGLE_ELEMENT_ARRAYS) - addRule(new Rules\\AssembleRule(new Assembler\\GetterAssembler( (new Assembler\\GetterAssemblerOptions()) - withReturnType() - withBoolGetters() ))) - addRule(new Rules\\TypenameMatchesRule( new Rules\\AssembleRule(new Assembler\\RequestAssembler()), '/Request$/' )) - addRule(new Rules\\TypenameMatchesRule( new Rules\\AssembleRule(new Assembler\\ResultAssembler()), '/Response$/' )) ; Luckily a command is provided to generate this for you in an interactive manner. Execute vendor/bin/soap-client generate:config to start the interactive config generator. wsdl String - REQUIRED The full path the the WSDL file you want to parse type destination String - REQUIRED The destination of the generated PHP classes. client destination String - REQUIRED The destination of the generated soap client. soapOptions Array - OPTIONAL The soap options you want to add to the SoapClient during code generation. Default values: [ 'trace' = false, 'exceptions' = true, 'keep_alive' = true, 'cache_wsdl' = WSDL_CACHE_NONE, ] type namespace String - OPTIONAL The namespace of the PHP Classes you want to generate. client namespace String - OPTIONAL The namespace of the generated client. client name String - OPTIONAL The class name of the client, defaults to 'Client'. classmap name Name of the classmap class classmap destination The location of a directory the classmap should be generated in. classmap namespace Name for the classmap rules RuleInterface - OPTIONAL You can specify how you want to generate your code. More information about the topic is available in the rules and assemblers section. The pre-defined rules are override-able by calling setRuleSet on the constucted object. For example, to make all your properties protected: Config::create() - setRuleSet( new Rules\\RuleSet( [ new Rules\\AssembleRule(new Assembler\\PropertyAssembler(PropertyGenerator::VISIBILITY_PROTECTED)), new Rules\\AssembleRule(new Assembler\\ClassMapAssembler()), ] ) )","title":"Configuration"},{"location":"code-generation/rules/","text":"Code generation rules Since every application has it's own rules on how to write and structure code, we made it possible to configure the way your code is auto generated. You can specify your own rules and apply them to the code generator. The goal of a rule is to run a code assembler. Here you can find a full list of built-in code assemblers . Built-in rules AssemblerRule ClientMethodMatchesRule MultiRule PopertynameMatchesRule TypeMapRule TypenameMatchesRule AssemblerRule use Phpro\\SoapClient\\CodeGenerator\\Assembler; use Phpro\\SoapClient\\CodeGenerator\\Rules; $rule = Rules\\AssembleRule(new Assembler\\GetterAssembler($someGetterOptions)) The AssemblerRule will always apply an assembler in the right context. This way, the code is added during every code generation command. In the example above, a getter will be created for every property in the SOAP type. ClientMethodMatchesRule use My\\Project\\CodeGenerator\\Assembler as CustomAssembler; use Phpro\\SoapClient\\CodeGenerator\\Assembler; use Phpro\\SoapClient\\CodeGenerator\\Rules; new Rules\\ClientMethodMatchesRule( new Rules\\AssembleRule(new CustomAssembler\\RemoveClientMethodAssembler()), '/demoSetup$/' ) The ClientMethodMatchesRule can be used in the types generation command and contains a subRule and a regular expression. The subRule is mostly a regular AssembleRule, but can be any class that implements the RuleInterface. The regular expression will be matched against the method name added to the generated Client. If the regular expression matches and the subRule is accepted, the defined assembler will run. In the example above, a custom RemoveClientMethodAssembler is is used to remove the demoSetup method from the Client completely. MultiRule use Phpro\\SoapClient\\CodeGenerator\\Assembler; use Phpro\\SoapClient\\CodeGenerator\\Rules; $rule = Rules\\MultiRule([ Rules\\AssembleRule(new Assembler\\GetterAssembler($someGetterOptions)), Rules\\AssembleRule(new Assembler\\SetterAssembler()), ]); The MultiRule makes it possible to define multiple rules that need to be applied on a SOAP type. This rule can be very handy in combination with rules like the TypeMapRule or TypenameMatchesRule . By using the MultiRule , you can e.g. specify the regex once but run multiple assemblers. In the example above, both the getters and setters are added for every property in the SOAP type. PropertynameMatchesRule use Phpro\\SoapClient\\CodeGenerator\\Assembler; use Phpro\\SoapClient\\CodeGenerator\\Rules; new Rules\\PropertynameMatchesRule( new Rules\\AssembleRule(new Assembler\\InterfaceAssembler(ApiKeyAwareInterface::class)), '/^ApiKey$/' ) The PropertynameMatchesRule can be used in the types generation command and contains a subRule and a regular expression. The subRule is mostly a regular AssmbleRule, but can be any class that implements the RuleInterface. The regular expression will be matched against the normalized SOAP property name. If the regular expression matches and the subRule is accepted, the defined assembler will run. In the example above, the ApiKeyAwareInterface is added to the class if the SOAP property ApiKey exists. TypeMapRule use Phpro\\SoapClient\\CodeGenerator\\Assembler; use Phpro\\SoapClient\\CodeGenerator\\Rules; $resultProviderRule = new Rules\\AssembleRule(new Assembler\\ResultProviderAssembler()); $defaultRule = new Rules\\AssembleRule(new Assembler\\ResultAssembler()); new Rules\\TypeMapRule( [ 'SomeType' = $resultProviderRule, 'NullType' = null ] $defaultRule ) The TypeMapRule can be used in the types generation command and contains a map of types with a subrule. When the SOAP type is found in the TypeMap, the configured rule will be applied. The last parameter is the default rule. When the type cannot be found in the TypeMap, the default Rule will apply. This rule will make it easy to apply some specific rules for specific templates. In the example above, the ResultProviderInterface is added to the class if the SOAP type equals SomeType . On the SOAP type NullType , no actions are executed. On all other SOAP types, the ResultInterface is added. TypenameMatchesRule use Phpro\\SoapClient\\CodeGenerator\\Assembler; use Phpro\\SoapClient\\CodeGenerator\\Rules; new Rules\\TypenameMatchesRule( new Rules\\AssembleRule(new Assembler\\RequestAssembler()), '/Request$/' ) The TypenameMatchesRule can be used in the types generation command and contains a subRule and a regular expression. The subRule is mostly a regular AssembleRule, but can be any class that implements the RuleInterface. The regular expression will be matched against the normalized SOAP type name. If the regular expression matches and the subRule is accepted, the defined assembler will run. In the example above, the RequestInterface is added to the class if the SOAP type ends on Request . Creating your own Rule Creating your own Rule is pretty easy. The only thing you'll need to do is implementing the RuleInterface . /** * Interface RuleInterface * * @package Phpro\\SoapClient\\CodeGenerator\\Rules */ interface RuleInterface { /** * @param ContextInterface $context * * @return bool */ public function appliesToContext(ContextInterface $context); /** * @param ContextInterface $context */ public function apply(ContextInterface $context); } Possible contexts: ClassMapContext : Triggered during the generate:classmap command. TypeContext : Triggered during the generate:types command for every type in the SOAP scheme. PropertyContext : Triggered during the generate:types command for every property in a SOAP type.","title":"Code generation rules"},{"location":"code-generation/rules/#code-generation-rules","text":"Since every application has it's own rules on how to write and structure code, we made it possible to configure the way your code is auto generated. You can specify your own rules and apply them to the code generator. The goal of a rule is to run a code assembler. Here you can find a full list of built-in code assemblers .","title":"Code generation rules"},{"location":"code-generation/rules/#built-in-rules","text":"AssemblerRule ClientMethodMatchesRule MultiRule PopertynameMatchesRule TypeMapRule TypenameMatchesRule","title":"Built-in rules"},{"location":"code-generation/rules/#assemblerrule","text":"use Phpro\\SoapClient\\CodeGenerator\\Assembler; use Phpro\\SoapClient\\CodeGenerator\\Rules; $rule = Rules\\AssembleRule(new Assembler\\GetterAssembler($someGetterOptions)) The AssemblerRule will always apply an assembler in the right context. This way, the code is added during every code generation command. In the example above, a getter will be created for every property in the SOAP type.","title":"AssemblerRule"},{"location":"code-generation/rules/#clientmethodmatchesrule","text":"use My\\Project\\CodeGenerator\\Assembler as CustomAssembler; use Phpro\\SoapClient\\CodeGenerator\\Assembler; use Phpro\\SoapClient\\CodeGenerator\\Rules; new Rules\\ClientMethodMatchesRule( new Rules\\AssembleRule(new CustomAssembler\\RemoveClientMethodAssembler()), '/demoSetup$/' ) The ClientMethodMatchesRule can be used in the types generation command and contains a subRule and a regular expression. The subRule is mostly a regular AssembleRule, but can be any class that implements the RuleInterface. The regular expression will be matched against the method name added to the generated Client. If the regular expression matches and the subRule is accepted, the defined assembler will run. In the example above, a custom RemoveClientMethodAssembler is is used to remove the demoSetup method from the Client completely.","title":"ClientMethodMatchesRule"},{"location":"code-generation/rules/#multirule","text":"use Phpro\\SoapClient\\CodeGenerator\\Assembler; use Phpro\\SoapClient\\CodeGenerator\\Rules; $rule = Rules\\MultiRule([ Rules\\AssembleRule(new Assembler\\GetterAssembler($someGetterOptions)), Rules\\AssembleRule(new Assembler\\SetterAssembler()), ]); The MultiRule makes it possible to define multiple rules that need to be applied on a SOAP type. This rule can be very handy in combination with rules like the TypeMapRule or TypenameMatchesRule . By using the MultiRule , you can e.g. specify the regex once but run multiple assemblers. In the example above, both the getters and setters are added for every property in the SOAP type.","title":"MultiRule"},{"location":"code-generation/rules/#propertynamematchesrule","text":"use Phpro\\SoapClient\\CodeGenerator\\Assembler; use Phpro\\SoapClient\\CodeGenerator\\Rules; new Rules\\PropertynameMatchesRule( new Rules\\AssembleRule(new Assembler\\InterfaceAssembler(ApiKeyAwareInterface::class)), '/^ApiKey$/' ) The PropertynameMatchesRule can be used in the types generation command and contains a subRule and a regular expression. The subRule is mostly a regular AssmbleRule, but can be any class that implements the RuleInterface. The regular expression will be matched against the normalized SOAP property name. If the regular expression matches and the subRule is accepted, the defined assembler will run. In the example above, the ApiKeyAwareInterface is added to the class if the SOAP property ApiKey exists.","title":"PropertynameMatchesRule"},{"location":"code-generation/rules/#typemaprule","text":"use Phpro\\SoapClient\\CodeGenerator\\Assembler; use Phpro\\SoapClient\\CodeGenerator\\Rules; $resultProviderRule = new Rules\\AssembleRule(new Assembler\\ResultProviderAssembler()); $defaultRule = new Rules\\AssembleRule(new Assembler\\ResultAssembler()); new Rules\\TypeMapRule( [ 'SomeType' = $resultProviderRule, 'NullType' = null ] $defaultRule ) The TypeMapRule can be used in the types generation command and contains a map of types with a subrule. When the SOAP type is found in the TypeMap, the configured rule will be applied. The last parameter is the default rule. When the type cannot be found in the TypeMap, the default Rule will apply. This rule will make it easy to apply some specific rules for specific templates. In the example above, the ResultProviderInterface is added to the class if the SOAP type equals SomeType . On the SOAP type NullType , no actions are executed. On all other SOAP types, the ResultInterface is added.","title":"TypeMapRule"},{"location":"code-generation/rules/#typenamematchesrule","text":"use Phpro\\SoapClient\\CodeGenerator\\Assembler; use Phpro\\SoapClient\\CodeGenerator\\Rules; new Rules\\TypenameMatchesRule( new Rules\\AssembleRule(new Assembler\\RequestAssembler()), '/Request$/' ) The TypenameMatchesRule can be used in the types generation command and contains a subRule and a regular expression. The subRule is mostly a regular AssembleRule, but can be any class that implements the RuleInterface. The regular expression will be matched against the normalized SOAP type name. If the regular expression matches and the subRule is accepted, the defined assembler will run. In the example above, the RequestInterface is added to the class if the SOAP type ends on Request .","title":"TypenameMatchesRule"},{"location":"code-generation/rules/#creating-your-own-rule","text":"Creating your own Rule is pretty easy. The only thing you'll need to do is implementing the RuleInterface . /** * Interface RuleInterface * * @package Phpro\\SoapClient\\CodeGenerator\\Rules */ interface RuleInterface { /** * @param ContextInterface $context * * @return bool */ public function appliesToContext(ContextInterface $context); /** * @param ContextInterface $context */ public function apply(ContextInterface $context); } Possible contexts: ClassMapContext : Triggered during the generate:classmap command. TypeContext : Triggered during the generate:types command for every type in the SOAP scheme. PropertyContext : Triggered during the generate:types command for every property in a SOAP type.","title":"Creating your own Rule"},{"location":"plugins/caching/","text":"Caching plugin This repository does not contain a caching plugin. If you want to be able to cache the methods in your SOAP client, you could use our annotated-cache package. This package will make it possible to specify the caching configuration in the annotations of your SOAP client. use Phpro\\AnnotatedCache\\Annotation\\Cacheable; class YourClient extends Client { /** * @Cacheable(pools= soapclient-pool , key= request , tags= helloworld , ttl=500) */ public function helloWorld(RequestInterface $request) { return $this- call('HelloWorld', $request); } }","title":"Caching plugin"},{"location":"plugins/caching/#caching-plugin","text":"This repository does not contain a caching plugin. If you want to be able to cache the methods in your SOAP client, you could use our annotated-cache package. This package will make it possible to specify the caching configuration in the annotations of your SOAP client. use Phpro\\AnnotatedCache\\Annotation\\Cacheable; class YourClient extends Client { /** * @Cacheable(pools= soapclient-pool , key= request , tags= helloworld , ttl=500) */ public function helloWorld(RequestInterface $request) { return $this- call('HelloWorld', $request); } }","title":"Caching plugin"},{"location":"plugins/logger/","text":"Logger plugin The logger plugin is activated automatically when you attach a LoggerInterface to the ClientBuilder . It will hook in to the Request, Response and Fault event and will log every step of the SOAP process. No more code pollution for logging!","title":"Logger plugin"},{"location":"plugins/logger/#logger-plugin","text":"The logger plugin is activated automatically when you attach a LoggerInterface to the ClientBuilder . It will hook in to the Request, Response and Fault event and will log every step of the SOAP process. No more code pollution for logging!","title":"Logger plugin"},{"location":"plugins/validator/","text":"Validator plugin It is possible to use the Symfony validator component to validate your request objects before sending them to the server. Since some servers return very cryptographic errors, the validation of request components could save you a lot of time during development. The validator plugin is activated automatically when you attach a ValidatorInterface to the ClientBuilder::withValidator() . It will hook in to the Request event and will throw a RequestException` when your request object doesn't contain valid data. No more crappy error messages from the soap server!","title":"Validator plugin"},{"location":"plugins/validator/#validator-plugin","text":"It is possible to use the Symfony validator component to validate your request objects before sending them to the server. Since some servers return very cryptographic errors, the validation of request components could save you a lot of time during development. The validator plugin is activated automatically when you attach a ValidatorInterface to the ClientBuilder::withValidator() . It will hook in to the Request event and will throw a RequestException` when your request object doesn't contain valid data. No more crappy error messages from the soap server!","title":"Validator plugin"}]}